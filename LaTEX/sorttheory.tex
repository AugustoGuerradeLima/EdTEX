\section{Teoria da Ordenação}

O \textbf{problema da ordenação} é recorrente em ciência da computação, seja a entrada da função de ordenação uma lista $[a_0,...,a_n]$, a saída deve ser uma permutação de forma que $a_0'<...<a_n'$.

Os algoritmos que realizam a ordenação são diversos, diz que um algoritmo ordena \textbf{no lugar} quando não são realizadas cópias do arranjo incipiente, ou de sub arranjos. Um algoritmo é \textbf{estável} se a ordem relativa de dois elementos não é alterada, isto é, dado dois elementos $a_0=a_1=k$, a permutação final deve estar ordenada de maneira que o elemento $a_0$ seja indexado antes do elemento $a_1$.

\subsection{Ordenação por bolha}

O algoritmo de ordenação por bolha, ou ordenação por flutuação é simples. O método \textbf{compara} elementos adjacentes e os \textbf{movimenta} se estiverem desordenados. Na primeira iteração o maior elemento se encontra no final do arranjo, então a próxima iteração não passa pela última posição. Ao fim da $k$-ésima iteração, é garantido que o $k$-ésimo maior elemento se encontra na sua posição ordenada.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{img/bubble_sort.jpg}
    \caption{Diagrama do algoritmo de ordenação por bolha em uma lista de inteiros, o maior elemento de um sub arranjo é "carregado" para sua posição correta.}
    \label{bubble_sort}
\end{figure}

\subsection{Ordenação por seleção}

A ordenação por seleção seleciona o $k$-ésimo menor elemento, guardando seu índice, e então o movimenta para sua posição correta. Mais uma vez as \textbf{comparações} e \textbf{trocas} são as operações mais relevantes desse algoritmo.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{img/selection_sort.jpg}
    \caption{Diagrama representando o algoritmo de ordenação por seleção, o menor elemento é encontrado e após isso trocado com o elemento que estava em sua posição, esse processo é repetido a cada sub lista, ordenando o arranjo inicial.}
    \label{insertion_sort}
\end{figure}

\subsection{Ordenação por inserção}

O método de ordenação por inserção é originalmente projetado para uma \textbf{lista encadeada}, isso não impede que ele seja aplicado para ordenação de arranjos. O algoritmo da ordenação por inserção consiste em selecionar um elemento, e compara-lo com os elementos que o antecedem na lista, encontrando sua posição correta e o inserindo nela. As operações relevantes para a complexidade são as \textbf{comparações} e as \textbf{movimentações}.

\subsection{Ordenação por intercalação}

A ordenação por intercalação, \textit{merge sort}, utiliza a estratégia de divisão e conquista para ordenar a lista incipiente. Na etapa de divisão, os sub arranjos são recursivamente divididos aproximadamente na metade, até que contenham apenas um elemento. Em seguida, na etapa de conquista, os elementos são intercalados formando um novo arranjo, agora ordenado, com tamanho sendo a soma dos dois arranjos anteriores.

\subsection{Ordenação rápida}

O algoritmo de ordenação rápida, \textit{quick sort}, possuí inúmeras implementações. O método escolhe um elemento \textbf{pivô}, em uma iteração pelo arranjo, elementos menores que o pivô são postos anteriormente a ele, o mesmo acontece com os elementos maiores, que são postos após o pivô. Após isso, ocorre a etapa de partição, onde o arranjo é segmentado e os novos arranjos gerados são iterados e também sofrem partições recursivamente até que se tenha a permutação ordenada.

\subsection{Ordenação de Donald Shell}

O método \textit{shell sort} é uma modificação do algoritmo de ordenação por inserção. Enquanto o \textit{insertion sort} realiza as comparações com elementos imediatamente adjacentes, a ordenação de Donald Shell arbitrariamente escolhe um \textbf{espaçamento} entre os elementos a serem comparados, a cada iteração esse espaçamento é diminuído por alguma regra até que a entrada é ordenada no fim do algoritmo. Na implementação canônica o espaceamento escolhido é a cada iteração $h = \frac{n}{2^{k-1}}$, onde $k$ é o número da iteração e $n$ o tamanho da entrada incipiente.

\subsection{Ordenação por contagem}

O algoritmo de ordenação por contagem não é baseado em comparação. Seja uma sequência com elementos entre $0$ e $k$, a abordagem desse método consiste em contar a quantidade de vezes que um elemento $x$ aparece no arranjo, guardando essa quantidade em uma $n$-upla, onde o número de ocorrências é posto no índice $x$ da $n$-upla, para determinar o tamanho da tupla de contagem é preciso conhecer $a priori$ o maior elemento $k$.

\subsection{Ordenação por balde}

A ordenação por balde é baseada em \textbf{intervalos} que os elementos do arranjo tomam. Cada intervalo divide o arranjo em sub arranjos, chamados de baldes. Dessa forma, após a segmentação dos elementos em baldes, cada sub arranjo é ordenado por um método de ordenação definido, por exemplo o método da ordenação por inserção.

\subsection{Ordenação por dígito}

A ordenação por dígito, \textit{radix sort}, ordena os elementos a partir de uma transformação de base, binária ou decimal, por exemplo, ordenando os elementos da lista inicial, dígito a dígito. No caso de uma ordenação por dígito binária, cada item é ordenado por sua representação binária (em \textit{bits}), o método realiza partições, segmentando o arranjo de forma similar ao \textit{quick sort}.
